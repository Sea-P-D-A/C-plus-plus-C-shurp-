/*
Отлично!Объясню всё простыми словами.

 Основные понятия :
1. Метод Гаусса со схемой единственного деления 
Это самый простой вариант метода Гаусса :

Как работает : Берём первую строку, делим ВСЕ её элементы на первый элемент(диагональный), чтобы получить 1 на диагонали

Зачем : Теперь легко вычесть эту строку из других, чтобы обнулить первый столбец ниже диагонали

Повторяем для всех строк сверху вниз

Проблема : Если диагональный элемент = 0 или очень мал → деление на 0 или большая погрешность!

Пример(система 2×2) :

    text
    2x + 3y = 8
    4x + 1y = 6
    Делим первую строку на 2 : x + 1.5y = 4

    Вычитаем из второй строки : (4x + y) - 4 * (x + 1.5y) = 6 - 4 * 4 → - 5y = -10

    Находим y = 2, подставляем → x = 1

    2. Обусловленность матрицы 
    Обусловленность = "насколько матрица чувствительна к ошибкам"

    Хорошо обусловленная(диагонально - доминантная) : Диагональные элементы БОЛЬШЕ суммы остальных в строке

    Пример : [10, 2; 1, 15] → 10 > 2, 15 > 1

    Свойство: Маленькие ошибки в данных → маленькие ошибки в решении

    В программе : fill_diag_dominant()

    Плохо обусловленная(матрица Гильберта) : Все элементы ОЧЕНЬ похожи

    Пример : [1, 0.5; 0.5, 0.333] → все числа маленькие и близкие

    Свойство : Маленькие ошибки в данных → БОЛЬШИЕ ошибки в решении!

    В программе : fill_hilbert() → A[i][j] = 1 / (i + j + 1)

    3. Норма невязки 
    Невязка = проверка правильности решения

    text
    r = A * x_calculated - b
    Что значит : Подставляем найденное решение x обратно в уравнение

    Должно быть : Если решение точное → r = 0 (на практике ≈ 10⁻¹⁵)

    Норма невязки = максимальный модуль компоненты r

    Зачем : Даже если решение не точно равно правильному, невязка должна быть мала

    4. Матрица Гильберта 
    Специальная "плохая" матрица для тестов :

text
H[i][j] = 1 / (i + j + 1)
Размер 3×3 :

    text
    [1, 1 / 2, 1 / 3]
    [1 / 2, 1 / 3, 1 / 4]
    [1 / 3, 1 / 4, 1 / 5]
    Проблема : Уже при n = 10 обусловленность ~10¹³(ужасно!)

    В эксперименте : Показывает слабость метода Гаусса без выбора ведущего элемента

    Работа с файлами в программе :
Пункт 2 меню : "Решить систему (из файла)"
Программа ожидает файлы в определённом формате :

1. Файл матрицы(например, matrix.txt) :
    text
    3 3            сначала количество строк и столбцов
    2.0 1.0 0.0    затем элементы построчно
    1.0 2.0 1.0
    0.0 1.0 2.0
    2. Файл правой части(например, rhs.txt) :
    text
    8.0            просто числа через пробел или новые строки
    10.0
    8.0
    Как создать тестовые файлы :
Создайте в папке с программой файлы test_matrix.txt и test_rhs.txt

Содержимое для теста 3×3 :

    test_matrix.txt :

    text
    3 3
    2.0 1.0 0.0
    1.0 2.0 1.0
    0.0 1.0 2.0
    test_rhs.txt:

text
8.0
10.0
8.0
Решение этой системы : x1 = 3, x2 = 2, x3 = 3

Или используйте готовые примеры :
cpp
// Можно вставить в начало main для автоматического создания файлов
void create_test_files() {
    std::ofstream mat("test_matrix.txt");
    mat << "3 3\n2.0 1.0 0.0\n1.0 2.0 1.0\n0.0 1.0 2.0\n";
    mat.close();

    std::ofstream rhs("test_rhs.txt");
    rhs << "8.0\n10.0\n8.0\n";
    rhs.close();

    std::cout << "Тестовые файлы созданы!\n";
}
Как проводить эксперименты :
Эксперимент 4 : "Зависимость от размера"
Что показывает :

text
Размер | Абс.погр. | Отн.погр.
10 | 1.2e-13 | 5.6e-13
20 | 3.4e-13 | 1.2e-12
50 | 8.9e-12 | 3.4e-11
100 | 2.3e-10 | 9.8e-10
Вывод: Чем больше система, тем больше накапливается ошибок округления.

Эксперимент 5 : "Зависимость от обусловленности"
Что показывает :

text
Тип матрицы | Абс.погр. | Отн.погр.
Случайная | 3.7e-13 | 1.9e-12
Гильберта | ОШИБКА | (деление на 0)
Диаг.Преобл. | 1.2e-14 | 4.5e-14
Вывод: Метод Гаусса без выбора ведущего элемента НЕ работает для плохо обусловленных матриц.

🛠 Что добавить в программу(опционально) :
    1. Автосоздание тестовых файлов :
cpp
void create_test_files() {
    // Матрица 3x3
    std::ofstream mat("example_matrix.txt");
    mat << "3 3\n";
    mat << "4.0  -1.0  0.0\n";
    mat << "-1.0  4.0 -1.0\n";
    mat << "0.0  -1.0  4.0\n";
    mat.close();

    // Правая часть
    std::ofstream rhs("example_rhs.txt");
    rhs << "7.0\n10.0\n7.0\n";
    rhs.close();

    std::cout << "Примеры файлов созданы:\n";
    std::cout << "  Матрица: example_matrix.txt\n";
    std::cout << "  Правая часть: example_rhs.txt\n";
    std::cout << "Решение: x1=2, x2=3, x3=2\n";
}

// Добавить в меню пункт 7
// case 7: create_test_files(); break;
2. Улучшенный метод Гаусса с обработкой нулей :
cpp
Vector solve_gauss_improved(const Vector & b) const {
    // ... тот же код ...

    for (size_t k = 0; k < n; ++k) {
        // ЕСЛИ диагональный элемент слишком мал
        if (std::abs(A[k][k]) < 1e-10) {
            // Ищем ненулевой элемент ниже в столбце
            size_t swap_row = k;
            for (size_t i = k + 1; i < n; ++i) {
                if (std::abs(A[i][k]) > std::abs(A[swap_row][k])) {
                    swap_row = i;
                }
            }

            // Меняем строки местами
            if (swap_row != k) {
                std::swap(A[k], A[swap_row]);
                std::swap(B[k], B[swap_row]);
            }

            // Если всё равно 0 → система вырожденная
            if (std::abs(A[k][k]) < 1e-15) {
                throw std::runtime_error("Система вырожденная");
            }
        }

        // Дальше обычный метод Гаусса...
    }
}
📝 Что писать в отчёте :
Цель работы : Изучение метода Гаусса для плотных матриц

Метод : Схема единственного деления(объяснить алгоритм)

Эксперимент 1 (размер) : Таблица с выводами

Эксперимент 2 (обусловленность) : Сравнение 3 типов матриц

Выводы :

Метод работает для хорошо обусловленных систем до ~100 уравнений

Для плохо обусловленных нужен выбор ведущего элемента

Точность падает с ростом размера из - за ошибок округления

Ваша программа полностью соответствует заданию!Можно смело защищать.

*/